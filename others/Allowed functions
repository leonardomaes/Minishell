----------------------------------------------
-- Variavel de ambiente --
getenv

Variaveis do OS que armazenam informacoes de configuracao e estado que podem ser acessaods
pelos programas em execucao.

char *getenv(const char *name);
// Usada para acessar o valor de uma variavel ambiente
-name: String que representa o nome da variavel de ambiente que deseja acessar (Nome deve ser exato, incluindo maiusculas e minusculas)
Return: Ponteiro para uma string, apontando para o valor associado ao nome da variavel
Ex: chamar getenv("HOME") e a variavel 'HOME' estiver definida como (/home/leonardo)
a funcao ira retornar um ponteiro para uma string "/home/leonardo"

Variaveis de ambiente no Linux:

User:
HOME: diretorio home do user;
USER ou LOGNAME: Nome do user;
UID: Identificador do user;
SHELL: Caminho do shell padrao (ex:/bin/bash)
PWD: diretorio de trabalho atual;
OLDPWD: Ultimo diretorio de trabalho;
MAIL: Caminho para caixa de entrada de e-mail;

Sistema:
PATH: Lista de diretorio onde executaveis sao procurados;
LD_LIBRARY_PATH: Diretorio para carregar Bibliotecas compartilhadas (LINUX);
EDITOR ou VISUAL: Editor de texto preferido do user;
LANG: Idioma e codificacao (ex: 'en_US.UTF8');
TERM: Tipo de terminal (ex: xterm-256color);
HOSTNAME: nome do computador;
TZ: Zona de tempo (ex: America/Sao_Paulo);

Sessoes;
DISPLAY: Indica servidor grafico em uso;
XDG_SESSION_TYPE: Tipo de sessao (ex: x11, wyland);
XDG_RUNTIME_DIR: Diretorio de runtime para a sessao;
SESSION_MANAGER: informacoes sobre a sessao do desktop;

Como usar:

#include <stdio.h>
#include <stdlib.h>

int main() {
    const char *home = getenv("HOME");
    if (home) {
        printf("Diretório home do usuário: %s\n", home);
    } else {
        printf("A variável HOME não está definida.\n");
    }

    return 0;
}

----------------------------------------------
--TERMCAPS - Caracteristicas do terminal / controle de string / manipulacao do terminal--

tputs - tgoto - tgetstr - tgetnum - tgetflag - tgetent

Biblioteca que permite obter informacoes sobre o terminal e executar comandos diferentes.

Como funciona:

Usa um banco de dados que armazena as informacoes e status do terminal

Funcoes:

<--------------->
-> int tgetent(char *bp, const chat *termtype);  -- Terminal Get Entry
// Carrega as informacoes do banco de dados para o tipo de terminal atual
-bp: buffer para armazenar a descricao do terminal (NULL para uso interno)
-termtype: Tipo do terminal (obtido atraves da variabel e ambiente 'TERM') (ex: xterm-256color)

#include <stdio.h>
#include <termcap.h>
int main() {
	char term_buffer[2048]; -- Buffer suficiente para descrever o terminal
	char *termtype = getenv("TERM");

	int status = tgetent(term_buffer, termtype);
	if (status == 1) {
		printf("Terminal %s configurado com sucesso!\n", termtype);
	} else if (status == 0) {
		printf("Terminal %s não encontrado.\n", termtype);
	} else {
		printf("Erro ao acessar o banco de dados Termcap.\n");
	}
	return 0;
}

<--------------->
-> int tgetnum(const char *id);
// Obtem valores numericos do terminal (Ex: dimensoes), deve ser usada apos a chamada da func tgetent();
-id: Identificador da capacidade numerica (ex: "co" para n de colunas, "li" para n de linhas).
Return: Valor numerico da capacidade, ou -1 se nao suportado

Flags:
co   Number of columns
dB   Delay in milliseconds for backspace on hardcopy terminals
dC   Delay in milliseconds for carriage return on hardcopy terminals
dF   Delay in milliseconds for form feed on hardcopy terminals
dN   Delay in milliseconds for new line on hardcopy terminals
dT   Delay in milliseconds for tabulator stop on hardcopy terminals
dV   Delay in milliseconds for vertical tabulator stop on hardcopy terminals
it   Difference between tab positions
lh   Height of soft labels
lm   Lines of memory
lw   Width of soft labels
li   Number of lines
Nl   Number of soft labels
pb   Lowest baud rate which needs padding
sg   Standout glitch
ug   Underline glitch
vt   virtual terminal number
ws   Width of status line if different from screen width

int     main()
{
  const char *name;
  char  *bp;
  char  *term;
  int   height;
  int   width;

  bp = malloc(sizeof(*bp));
  name = "TERM";
  if ((term = getenv(name)) == NULL)
	return (1);
  printf("My terminal is %s.\n", term);
  tgetent(bp, term);
  height = tgetnum("li");
  width = tgetnum("co");
  printf("H : %d\nL : %d\n", height, width);
  free(bp);
  return (0);
}

<--------------->
-> int tgetflag(const char *id);
// Verifica capacidade booleana, deve ser usada apos a chamada das funcs getenv() e tgetent()
-id: Identificador da capacidade booleana (ex: "am" para "auto-margin").

flags:
5i   Printer will not echo on screen
am   Automatic margins which means automatic line wrap
bs   Control-H (8 dec.) performs a backspace
bw   Backspace on left margin wraps to previous line and right margin
da   Display retained above screen
db   Display retained below screen
eo   A space erases all characters at cursor position
es   Escape sequences and special characters work in status line
gn   Generic device
hc   This is a hardcopy terminal
HC   The cursor is hard to see when not on bottom line
hs   Has a status line
hz   Hazeltine bug, the terminal can not print tilde characters
in   Terminal inserts null bytes, not spaces, to fill whitespace
km   Terminal has a meta key
mi   Cursor movement works in insert mode
ms   Cursor movement works in standout/underline mode
NP   No pad character
NR   ti does not reverse te
nx   No padding, must use XON/XOFF
os   Terminal can overstrike
ul   Terminal underlines although it can not overstrike
xb   Beehive glitch, f1 sends ESCAPE, f2 sends ^C
xn   Newline/wraparound glitch
xo   Terminal uses xon/xoff protocol
xs   Text typed over standout text will be displayed in standout
xt   Teleray glitch, destructive tabs and odd standout mode



<--------------->
-> char *tgetstr(const char *id, char **area);
// Obtem a capacidade de uma string
-id: Identificador da capacidade de string (ex: "cl" para limpar tela, "cm" para mover o cursor)
-area: Ponteiro para onde a string sera armazenada
return: Ponteiro para uma string correspondente

Flags: "man termcap" no terminal para ver possiveis flags

<--------------->
-> char *tgoto(const char *cap, int col, int row); -- Terminal Go To Position
// Construir uma string de controle com parametros, como posicoes de linha e colunas
-cap: String de controle (obtida por tgetstr ex: "cm" que move o cursor)
-col/row: Coluna e linha que o cursor deve ser movido
Return: String formatada com os parametros

<--------------->
-> int tputs(const char *str, int affcnt, int (*putc)(int)); -- Terminal Put String
// Envia uma string de controle ao terminal
-str: String de controle a ser enviada
-affcnt: Numero de linhas afetadas
-putc: Funcao para enviar Caracteres ao terminal (putchar() por exemplo)


if (clear_screen) {  -- Limpa a tela
    tputs(clear_screen, 1, putchar); // Limpa a tela
}

---------------------------------------------- TERMIOS
tcgetattr - tcsetattr
Controlar as configuracoes do terminal Unix, manipula o comportamento, como
desativar modo canonico(leitura linha a linha) ou desabilitar o eco de entrada no terminal

-> Struct:
struct termios {
    tcflag_t c_iflag;  // Configurações de entrada
    tcflag_t c_oflag;  // Configurações de saída
    tcflag_t c_cflag;  // Configurações de controle
    tcflag_t c_lflag;  // Configurações locais (modo de linha, eco, etc.)
    cc_t     c_cc[NCCS]; // Caracteres de controle (como EOF, EOL, etc.)
};

-> int tcgetattr(int filedes, struct termios *termios_p);
// Obtem as config atuais do terminal e armazena na struct
-filedes: file descriptor aberto associado ao terminal
-termios_p: ponteiro para a struct do termios
tcgetattr(STDIN_FILENO, &t);
struct termios t;

-> int tcsetattr(int fildes, int optional_actions, const struct termios *termios_p);
// Define novas configs do terminal
	
tcsetattr(STDIN_FILENO, TCSANOW, &t);
Flags:
TCSANOW: Aplica imediatamente.
TCSADRAIN: Espera esvaziar a saída antes de aplicar.
TCSAFLUSH: Descarrega entrada e saída pendentes antes de aplicar.

---------------------------------------------- IOCTL - Control Device
ioctl


---------------------------------------------- NAVEGAR POR DIRETORIOS
opendir - readdir - closedir
Abrir, ler e fechar conteudo do diretorio

int main()
{
	DIR* dir = opendir(".");
	if (dir == NULL)
	{
		return (1);
	}
	struct dirent* entity;
	entity = readdir(dir);
	while (entity != NULL)
	{
		printf("%s\n", entity->d_name);
		entity = readdir(dir);
	}

	closedir(dir);
	return (0);
}

---------------------------------------------- SIGNALS

signal - sigaction - sigemptyset - sigaddset - kill



---------------------------------------------- BASICOS

printf - malloc - free - write - open - read - close - exit

---------------------------------------------- COMANDOS DO PIPEX

access - fork - pipe - strerror - perror - execve
wait - waitpid - wait3 - wait4 - dup - dup2


---------------------------------------------- READLINE

readline - rl_clear_history - rl_on_new_line - rl_replace_line - rl_redisplay - add_history


----------------------------------------------



getcwd, chdir, stat, lstat, fstat, unlink,

isatty, ttyname, ttyslot

